30a31
> from twisted.internet.defer import maybeDeferred
477d477
< 
794a795
>       self.pendingOnConnect = False
1009a1011,1014
>       
>       # True, iff I am waiting for the OnConnect call to return, i.e. waiting
>       # for Deferred to fire
>       self.pendingOnConnect = False
1179c1184,1185
<          self.processHandshake()
---
>          if not self.pendingOnConnect:
>             self.processHandshake()
2683a2690
>             key = key1, key2, key3
2694,2722c2701,2736
<          try:
<             connectionRequest = ConnectionRequest(self.peer,
<                                                   self.peerstr,
<                                                   self.http_headers,
<                                                   self.http_request_host,
<                                                   self.http_request_path,
<                                                   self.http_request_params,
<                                                   self.websocket_version,
<                                                   self.websocket_origin,
<                                                   self.websocket_protocols,
<                                                   self.websocket_extensions)
< 
<             ## onConnect() will return the selected subprotocol or None
<             ## or raise an HttpException
<             ##
<             protocol = self.onConnect(connectionRequest)
< 
<             if protocol is not None and not (protocol in self.websocket_protocols):
<                raise Exception("protocol accepted must be from the list client sent or None")
< 
<             self.websocket_protocol_in_use = protocol
< 
<          except HttpException, e:
<             return self.failHandshake(e.reason, e.code)
<             #return self.sendHttpRequestFailure(e.code, e.reason)
< 
<          except Exception, e:
<             log.msg("Exception raised in onConnect() - %s" % str(e))
<             return self.failHandshake("Internal Server Error", HTTP_STATUS_CODE_INTERNAL_SERVER_ERROR[0])
---
>          connectionRequest = ConnectionRequest(self.peer,
>                                                self.peerstr,
>                                                self.http_headers,
>                                                self.http_request_host,
>                                                self.http_request_path,
>                                                self.http_request_params,
>                                                self.websocket_version,
>                                                self.websocket_origin,
>                                                self.websocket_protocols,
>                                                self.websocket_extensions)
>          
>          ## onConnect() will return the selected subprotocol or None
>          ## or raise an HttpException (or a Deferred)
>          ##
>          protocol = maybeDeferred(self.onConnect, connectionRequest)
>          protocol.addCallback(self._processHandshake_buildResponse, key)
>          protocol.addErrback(self._processHandshake_failed)
> 
>          self.pendingOnConnect = True
> 
>    def _processHandshake_buildResponse(self, protocol, key):
>       """
>       """
>       self.pendingOnConnect = False
>       
>       if protocol is not None and not (protocol in self.websocket_protocols):
>          raise Exception("protocol accepted must be from the list client sent or None")
>       
>       self.websocket_protocol_in_use = protocol
>       
>       if self.websocket_version == 0:
>             key1, key2, key3 = key
>       
>       ## build response to complete WebSocket handshake
>       ##
>       response  = "HTTP/1.1 %d Switching Protocols\x0d\x0a" % HTTP_STATUS_CODE_SWITCHING_PROTOCOLS[0]
2723a2738,2739
>       if self.factory.server is not None and self.factory.server != "":
>          response += "Server: %s\x0d\x0a" % self.factory.server.encode("utf-8")
2725,2727c2741,2742
<          ## build response to complete WebSocket handshake
<          ##
<          response  = "HTTP/1.1 %d Switching Protocols\x0d\x0a" % HTTP_STATUS_CODE_SWITCHING_PROTOCOLS[0]
---
>       response += "Upgrade: WebSocket\x0d\x0a"
>       response += "Connection: Upgrade\x0d\x0a"
2729,2730c2744,2745
<          if self.factory.server is not None and self.factory.server != "":
<             response += "Server: %s\x0d\x0a" % self.factory.server.encode("utf-8")
---
>       if self.websocket_protocol_in_use is not None:
>          response += "Sec-WebSocket-Protocol: %s\x0d\x0a" % str(self.websocket_protocol_in_use)
2732,2733c2747,2750
<          response += "Upgrade: WebSocket\x0d\x0a"
<          response += "Connection: Upgrade\x0d\x0a"
---
>       if self.websocket_version == 0:
>          if self.websocket_origin:
>             ## browser client provide the header, and expect it to be echo'ed
>             response += "Sec-WebSocket-Origin: %s\x0d\x0a" % str(self.websocket_origin)
2735,2736c2752,2753
<          if self.websocket_protocol_in_use is not None:
<             response += "Sec-WebSocket-Protocol: %s\x0d\x0a" % str(self.websocket_protocol_in_use)
---
>          if self.debugCodePaths:
>             log.msg('factory isSecure = %s port = %s' % (self.factory.isSecure, self.factory.externalPort))
2738c2755,2762
<          if self.websocket_version == 0:
---
>          if (self.factory.isSecure and self.factory.externalPort != 443) or ((not self.factory.isSecure) and self.factory.externalPort != 80):
>             if self.debugCodePaths:
>                log.msg('factory running on non-default port')
>             response_port = ':' + str(self.factory.externalPort)
>          else:
>             if self.debugCodePaths:
>                log.msg('factory running on default port')
>             response_port = ''
2740,2742c2764,2770
<             if self.websocket_origin:
<                ## browser client provide the header, and expect it to be echo'ed
<                response += "Sec-WebSocket-Origin: %s\x0d\x0a" % str(self.websocket_origin)
---
>          ## FIXME: check this! But see below ..
>          if False:
>             response_host = str(self.factory.host)
>             response_path = str(self.factory.path)
>          else:
>             response_host = str(self.http_request_host)
>             response_path = str(self.http_request_uri)
2744,2745c2772
<             if self.debugCodePaths:
<                log.msg('factory isSecure = %s port = %s' % (self.factory.isSecure, self.factory.externalPort))
---
>          location = "%s://%s%s%s" % ('wss' if self.factory.isSecure else 'ws', response_host, response_port, response_path)
2747,2754c2774,2775
<             if (self.factory.isSecure and self.factory.externalPort != 443) or ((not self.factory.isSecure) and self.factory.externalPort != 80):
<                if self.debugCodePaths:
<                   log.msg('factory running on non-default port')
<                response_port = ':' + str(self.factory.externalPort)
<             else:
<                if self.debugCodePaths:
<                   log.msg('factory running on default port')
<                response_port = ''
---
>          # Safari is very picky about this one
>          response += "Sec-WebSocket-Location: %s\x0d\x0a" % location
2756,2762c2777,2778
<             ## FIXME: check this! But see below ..
<             if False:
<                response_host = str(self.factory.host)
<                response_path = str(self.factory.path)
<             else:
<                response_host = str(self.http_request_host)
<                response_path = str(self.http_request_uri)
---
>          ## end of HTTP response headers
>          response += "\x0d\x0a"
2764c2780,2790
<             location = "%s://%s%s%s" % ('wss' if self.factory.isSecure else 'ws', response_host, response_port, response_path)
---
>          ## compute accept body
>          ##
>          accept_val = struct.pack(">II", key1, key2) + key3
>          accept = hashlib.md5(accept_val).digest()
>          response_body = str(accept)
>       else:
>          ## compute Sec-WebSocket-Accept
>          ##
>          sha1 = hashlib.sha1()
>          sha1.update(key + WebSocketProtocol.WS_MAGIC)
>          sec_websocket_accept = base64.b64encode(sha1.digest())
2766,2767c2792
<             # Safari is very picky about this one
<             response += "Sec-WebSocket-Location: %s\x0d\x0a" % location
---
>          response += "Sec-WebSocket-Accept: %s\x0d\x0a" % sec_websocket_accept
2769,2770c2794,2795
<             ## end of HTTP response headers
<             response += "\x0d\x0a"
---
>          if len(self.websocket_extensions_in_use) > 0:
>             response += "Sec-WebSocket-Extensions: %s\x0d\x0a" % ','.join(self.websocket_extensions_in_use)
2772,2791c2797,2799
<             ## compute accept body
<             ##
<             accept_val = struct.pack(">II", key1, key2) + key3
<             accept = hashlib.md5(accept_val).digest()
<             response_body = str(accept)
<          else:
<             ## compute Sec-WebSocket-Accept
<             ##
<             sha1 = hashlib.sha1()
<             sha1.update(key + WebSocketProtocol.WS_MAGIC)
<             sec_websocket_accept = base64.b64encode(sha1.digest())
< 
<             response += "Sec-WebSocket-Accept: %s\x0d\x0a" % sec_websocket_accept
< 
<             if len(self.websocket_extensions_in_use) > 0:
<                response += "Sec-WebSocket-Extensions: %s\x0d\x0a" % ','.join(self.websocket_extensions_in_use)
< 
<             ## end of HTTP response headers
<             response += "\x0d\x0a"
<             response_body = ''
---
>          ## end of HTTP response headers
>          response += "\x0d\x0a"
>          response_body = ''
2793,2794c2801,2802
<          if self.debug:
<             log.msg("sending HTTP response:\n\n%s%s\n\n" % (response, binascii.b2a_hex(response_body)))
---
>       if self.debug:
>          log.msg("sending HTTP response:\n\n%s%s\n\n" % (response, binascii.b2a_hex(response_body)))
2796,2799c2804,2807
<          ## save and send out opening HS data
<          ##
<          self.http_response_data = response + response_body
<          self.sendData(self.http_response_data)
---
>       ## save and send out opening HS data
>       ##
>       self.http_response_data = response + response_body
>       self.sendData(self.http_response_data)
2801,2803c2809,2811
<          ## opening handshake completed, move WebSockets connection into OPEN state
<          ##
<          self.state = WebSocketProtocol.STATE_OPEN
---
>       ## opening handshake completed, move WebSockets connection into OPEN state
>       ##
>       self.state = WebSocketProtocol.STATE_OPEN
2805,2811c2813,2819
<          ## cancel any opening HS timer if present
<          ##
<          if self.openHandshakeTimeoutCall is not None:
<             if self.debugCodePaths:
<                log.msg("openHandshakeTimeoutCall.cancel")
<             self.openHandshakeTimeoutCall.cancel()
<             self.openHandshakeTimeoutCall = None
---
>       ## cancel any opening HS timer if present
>       ##
>       if self.openHandshakeTimeoutCall is not None:
>          if self.debugCodePaths:
>             log.msg("openHandshakeTimeoutCall.cancel")
>          self.openHandshakeTimeoutCall.cancel()
>          self.openHandshakeTimeoutCall = None
2813,2817c2821,2825
<          ## init state
<          ##
<          self.inside_message = False
<          if self.websocket_version != 0:
<             self.current_frame = None
---
>       ## init state
>       ##
>       self.inside_message = False
>       if self.websocket_version != 0:
>          self.current_frame = None
2819,2821c2827,2829
<          ## fire handler on derived class
<          ##
<          self.onOpen()
---
>       ## fire handler on derived class
>       ##
>       self.onOpen()
2823,2826c2831,2847
<          ## process rest, if any
<          ##
<          if len(self.data) > 0:
<             self.consumeData()
---
>       ## process rest, if any
>       ##
>       if len(self.data) > 0:
>          self.consumeData()
>    
>    def _processHandshake_failed(self, failure):
>       """
>       """
>       self.pendingOnConnect = False
>       e = failure.value
>       
>       if failure.check(HttpException):
>          return self.failHandshake(e.reason, e.code)
>          #return self.sendHttpRequestFailure(e.code, e.reason)
>       else:
>          log.msg("Exception raised in onConnect() - %s" % str(e))
>          return self.failHandshake("Internal Server Error", HTTP_STATUS_CODE_INTERNAL_SERVER_ERROR[0])
3342c3363
<          http_version = sl[0].strip()
---
>          http_version = sl[0]
3349c3370
<             status_code = int(sl[1].strip())
---
>             status_code = int(sl[1])
3351c3372
<             return self.failHandshake("Bad HTTP status code ('%s')" % sl[1].strip())
---
>             return self.failHandshake("Bad HTTP status code ('%s')" % sl[1])
3358c3379
<                reason = " - %s" % sl[2].strip()
---
>                reason = " - %s" % ' '.join(sl[2:])
