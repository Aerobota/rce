#!/usr/bin/env python
# -*- coding: utf-8 -*-
#     
#     base.py
#     
#     This file is part of the RoboEarth Cloud Engine framework.
#     
#     This file was originally created for RoboEearth
#     http://www.roboearth.org/
#     
#     The research leading to these results has received funding from
#     the European Union Seventh Framework Programme FP7/2007-2013 under
#     grant agreement no248942 RoboEarth.
#     
#     Copyright 2012 RoboEarth
#     
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#     
#     http://www.apache.org/licenses/LICENSE-2.0
#     
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#     
#     \author/s: Dominique Hunziker 
#     
#     

# Python specific imports
from types import MethodType
from weakref import WeakSet

# twisted specific imports
from twisted.python.failure import Failure
from twisted.internet.defer import Deferred, succeed, fail
from twisted.spread.pb import DeadReferenceError, PBConnectionLost


class AlreadyDead(Exception):
    """ Exception is raised when a death notifier callback is registered with
        an already dead proxy.
    """


class _DeferredMethod(object):
    """ Wrapper to mark a method for the Proxy metaclass. The returned object
        is of type Deferred.
    """
    __slots__ = ['method']
    
    def __init__(self, method):
        """ Initialize the Marker.
            
            @param method:      Reference to function which has been marked.
            @type  method:      callable
        """
        self.method = method


class _ProxyMethod(object):
    """ Wrapper to mark a method for the Proxy metaclass. The returned object
        is of type Proxy.
    """
    __slots__ = ['method', 'cls']
    
    def __init__(self, method, cls):
        """ Initialize the Marker.
            
            @param method:      Reference to function which has been marked.
            @type  method:      callable
            
            @param cls:         Class which will be used to instantiate the
                                returned object.
            @param cls:         rce.master.base.Proxy
        """
        self.method = method
        self.cls = cls


class _Destructor(object):
    """ Wrapper to mark a method for the Proxy metaclass. The marked method
        will be used as a destructor for the class auto-generated by the Proxy
        metaclass.
    """
    __slots__ = ['method']
    
    def __init__(self, method):
        """ Initialize the Marker.
            
            @param method:      Reference to function which has been marked.
            @type  method:      callable
        """
        self.method = method


class _RedirectedMethodBase(object):
    """ Abstract base class for methods modified by the Proxy metaclass.
        
        The class will be inserted as an unbound method into a Proxy class
        by the Proxy metaclass. It forwards the call to another object which
        should be an instance of the class auto-generated by the Proxy
        metaclass. The reference to the other object is retrieved using the
        '__call__' method of the Proxy instance which will be passed as 'self'
        to the method. As the reference is returned as a Deferred the call will
        also be a deferred call.
    """
    def __init__(self, name, doc):
        """ Initialize the modified method.
            
            @param name:        Name of the method remote method. The name is
                                also used for this callable object.
            @type  name:        str
            
            @param doc:         Doc string of this callable object.
            @type  doc:         str
        """
        self.__name__ = name
        self.__doc__ = doc
    
    def _makeProxy(self, instance):
        """ Internally used method which is used as a hook to instantiate the
            return object of the method.
        """
        raise NotImplementedError('_RedirectedMethodBase can not be used '
                                  'directly.')
    
    def _call(self, ref, (args, kw)):
        """ Internally used method which is used as a callback to call the
            method of the retrieved reference.
        """
        return getattr(ref, self.__name__)(*args, **kw)
    
    def _filter(self, failure, instance):
        """ Internally used method which is used as an errback to check the
            failure for errors indicating that the Proxy is dead.
        """
        if failure.check(DeadReferenceError, PBConnectionLost):
            instance.notify(failure)
        else:
            print('Received the following error message when calling {0} from '
                  'class {1}: {2}'.format(self.__name__,
                                          instance.__class__.__name__,
                                          failure.getErrorMessage()))
        
        return failure
    
    def _callback(self, result, proxy):
        """ Internally used method which is used as a hook to hand the result
            of the successful call to the previously returned object.
        """
        raise NotImplementedError('_RedirectedMethodBase can not be used '
                                  'directly.')
    
    def _errback(self, failure, proxy):
        """ Internally used method which is used as a hook to hand the failure
            of call to the previously returned object.
        """
        raise NotImplementedError('_RedirectedMethodBase can not be used '
                                  'directly.')
    
    def __call__(self, instance, *args, **kw):
        proxy = self._makeProxy(instance)
        d = instance()
        d.addCallback(self._call, (args, kw))
        d.addErrback(self._filter, instance)
        d.addCallbacks(self._callback, self._errback,
                       callbackArgs=(proxy,), errbackArgs=(proxy,))
        return proxy
    
    def __get__(self, instance, owner):
        return MethodType(self, instance, owner)


class _RedirectedMethodDeferred(_RedirectedMethodBase):
    """ Modified method which redirects a call to another object and returning
        the result of the call as a Deferred.
    """
    def _makeProxy(self, instance):
        return Deferred()
    
    def _callback(self, result, proxy):
        proxy.callback(result)
    
    def _errback(self, failure, proxy):
        proxy.errback(failure)


class _RedirectedMethodProxy(_RedirectedMethodBase):
    """ Modified method which redirects a call to another object and returning
        the result of the call as a Proxy.
    """
    def __init__(self, name, doc, proxyCls):
        """ Initialize the modified method.
            
            @param name:        Name of the method remote method. The name is
                                also used for this callable object.
            @type  name:        str
            
            @param doc:         Doc string of this callable object.
            @type  doc:         str
            
            @param proxyCls:    Proxy class which will be instantiated to
                                create the returned objects.
            @type  proxyCls:    rce.master.base.Proxy
        """
        super(_RedirectedMethodProxy, self).__init__(name, doc)
        self._proxyCls = proxyCls
    
    def _makeProxy(self, instance):
        return self._proxyCls(instance)
    
    def _callback(self, result, proxy):
        proxy.createRemoteObject(result)
    
    def _errback(self, failure, proxy):
        proxy.registerFailureObject(failure)


class RemoteObject(object):
    """ Base class for class auto-generated by the Proxy metaclass.
        
        The class will contain all marked methods from the Proxy class.
    """
    def __init__(self, obj, handler):
        """ Initialize the remote object.
            
            @param obj:         Reference to the remote object.
            @type  obj:         twisted.spread.pb.RemoteReference
            
            @param handler:     Proxy instance which is used to call this
                                instance.
            @type  handler:     rce.master.base.Proxy
        """
        self.obj = obj
        handler.registerDeferredObject(self)
    
    def notifyOnDisconnect(self, cb):
        """ Register a callback which will be called once the remote object
            is no longer connected to this process.
        """
        self.obj.notifyOnDisconnect(cb)
    
    def dontNotifyOnDisconnect(self, cb):
        """ Unregister a callback which would have been called once the remote
            object is no longer connected to this process.
        """
        self.obj.dontNotifyOnDisconnect(cb)


class ProxyMeta(type):
    """ Metaclass for the Proxy class.
        
        The metaclass searches for all marked methods in the Proxy class.
        They will be all added to an auto-generated class and in the
        Proxy class they will be replaced by subclasses of 
        rce.master.base._RedirectedMethodBase. The auto-generated class will
        be registered with the Proxy class as the attribute '_REMOTE_CLS'.
    """
    def __new__(mcs, name, bases, dict): #@ReservedAssignment @NoSelf
        rmtDict = {}
        
        for attrName, attr in dict.iteritems():
            if isinstance(attr, _DeferredMethod):
                rmtDict[attrName] = attr.method
                dict[attrName] = _RedirectedMethodDeferred(attrName,
                                                           attr.method.__doc__)
            elif isinstance(attr, _ProxyMethod):
                rmtDict[attrName] = attr.method
                dict[attrName] = _RedirectedMethodProxy(attrName,
                                                        attr.method.__doc__,
                                                        attr.cls)
            elif isinstance(attr, _Destructor):
                if '__del__' in rmtDict:
                    raise TypeError("Class '{0}' can have only one "
                                    'destructor.'.format(name))
                
                attr.method.__name__ = '__del__'
                rmtDict['__del__'] = attr.method
        
        rmtBases = tuple(getattr(base, '_REMOTE_CLS') for base in bases
                         if hasattr(base, '_REMOTE_CLS')) or (RemoteObject,)
        dict['_REMOTE_CLS'] = type('Remote{0}'.format(name), rmtBases, rmtDict)
        
        return type.__new__(mcs, name, bases, dict)


class Proxy(object):
    """ Base class for a Proxy. It is a construct which allows the usage of
        a RemoteReference, before the reference can be created, while avoiding
        the explicit usage of Deferreds. Deferreds are still used, but the
        usage is hidden by the implementation of the Proxy class.
    """
    __metaclass__ = ProxyMeta
    
    @staticmethod
    def returnDeferred(method):
        """ Proxy Metaclass Marker.
            
            Decorator which marks the decorated method to be added to the
            remote object and whose result is returned as a Deferred.
        """
        return _DeferredMethod(method)
    
    @staticmethod
    def returnProxy(cls):
        """ Proxy Metaclass Marker.
            
            Decorator which marks the decorated method to be added to the
            remote object and whose result is returned as another Proxy.
            
            @param cls:         Proxy class which should be used for the
                                creation of return objects.
            @type  cls:         rce.master.base.Proxy
        """
        def decorator(method):
            return _ProxyMethod(method, cls)
        return decorator
    
    @staticmethod
    def destroyProxy(method):
        """ Proxy Metaclass Marker.
            
            Decorator which marks the decorated method to be added to the
            remote object as the destructor '__del__'.
            
            Only one method per class can be marked as destructor!
        """
        return _Destructor(method)
    
    def __init__(self, *args, **kw):
        """ Initialize the Proxy.
        """
        super(Proxy, self).__init__(*args, **kw)
        
        self.__obj = None
        self.__failure = None
        self.__refs = WeakSet()
        
        self.__cbs = set()
        self.__pending = []
    
    def createRemoteObject(self, obj):
        """ Create the remote object which provides the necessary methods for
            this Proxy class.
            
            @param obj:         Object which will be passed as the first
                                argument to the RemoteObject constructor.
            @type  obj:         twisted.spread.pb.RemoteReference
        """
        return self._REMOTE_CLS(obj, self)
    
    def registerDeferredObject(self, obj):
        """ Register the remote object which provides the necessary methods for
            this Proxy class.
            Normally, should only be called by the RemoteObject class during
            initialization.
            
            @param obj:         Remote object which should be registered.
            @type  obj:         rce.master.base.RemoteObject
        """
        assert self.__obj is None, 'Only one object can be registered.'
        assert not isinstance(obj, Failure)
        
        self.__obj = obj
        
        if isinstance(obj, RemoteObject):
            obj.notifyOnDisconnect(self.__disconnected)
        
        for pending in self.__pending:
            pending.callback(obj)
        
        self.__pending = None
    
    def registerFailureObject(self, f):
        """ Register a failure object which was received during the creation
            of the object in the remote process.
            
            @param f:           Failure object which should be registered.
            @type  f:           twisted.python.failure.Failure
        """
        assert self.__obj is None, 'Only one object can be registered.'
        assert isinstance(f, Failure), "Failure has to be of type 'Failure'."
        self.notify(f)
    
    def notifyOnDeath(self, cb):
        """ Register a callback which will be called once the remote object is
            dead, i.e. no longer connected to this process or a failure was
            received.
            
            @param cb:          Callback which should be registered. It should
                                take this instance as only argument.
            @type  cb:          callable
        """
        assert callable(cb)
        
        try:
            self.__cbs.add(cb)
        except AttributeError:
            raise AlreadyDead('{0} is already '
                              'dead.'.format(self.__class__.__name__))
    
    def dontNotifyOnDeath(self, cb):
        """ Unregister a callback which would have been called once the remote
            object is dead.
            
            @param cb:          Callback which should be unregistered.
            @type  cb:          callable
        """
        try:
            self.__cbs.remove(cb)
        except AttributeError:
            pass
    
    def __call__(self):
        """ Return a reference to the remote object as soon as the reference
            is available.
            
            @return:            Reference to the RemoteObject instance.
                                (type: rce.master.base.RemoteReference)
            @rtype:             twisted::Deferred
        """
        if self.__failure is not None:
            return fail(self.__failure)
        
        if self.__pending is not None:
            d = Deferred()
            self.__pending.append(d)
            return d
        
        return succeed(self.__obj)
    
    def notify(self, failure):
        """ Method is used as a callback to inform the proxy that a failure
            occurred.
        """
        if self.__failure:
            return
        
        if self.__obj and isinstance(self.__obj, RemoteObject):
            self.__obj.dontNotifyOnDisconnect(self.__disconnected)
        
        self.__failure = failure
        self.__obj = ()
        
        if self.__pending is not None:
            for pending in self.__pending:
                pending.errback(failure)
            
            self.__pending = None
        
        for cb in self.__cbs:
            cb(self)
        
        self.__cbs = None
    
    def destroy(self):
        """ Method should be called to destroy the Proxy as well as the remote
            object.
        """
        self.__destroy()
    
    def __destroy(self):
        self.notify(Failure(DeadReferenceError('Reference is deleted.')))
    
    def __disconnected(self, _):
        self.notify(Failure(DeadReferenceError('Reference is dead.')))
    
    def __del__(self):
        self.__destroy()
